核心原理: 基于HystrixCommand注解的 HystrixCommandAspect 切面

#####################################

限流: 限制并发的请求访问量, 超过阈值则拒绝.

降级: 服务分优先级, 牺牲非核心服务（不可用）, 保证核心服务稳定, 从整体负荷考虑.
服务降级是对系统整体资源的合理分配, 区分核心服务和非核心服务.
对某个服务的访问延迟时间、异常等情况做出预估并给出兜底方法.

熔断: 依赖的下游服务故障触发熔断, 避免引发本系统崩溃, 系统自动执行和恢复.
在Spring Cloud框架里, 熔断机制通过Hystrix实现. Hystrix会监控微服务间调用的状况,
当失败的调用到一定阈值, 缺省是5秒内20次调用失败, 就会启动熔断机制.

#####################################

Hystrix工作原理:
通过command来解耦请求与返回操作, 在具体的实例中就是, Hystrix会对依赖的服务进行观察,
通过command.toObservable调用返回一个观察的对象, 同时发起一个事件, 然后用Subscriber对接受到的事件进行处理.
在command命令发出请求后, 它通过一系列的判断, 顺序依次是缓存是否命中、断路器是否打开、线程池是否占满,
然后它才会开始对我们编写的代码进行实际的请求依赖服务的处理, 也就是Hystrix.run方法, 如果在这其中任一节点出现错误或者抛出异常,
它都会返回到fallback方法进行服务降级处理, 当降级处理完成之后, 它会将结果返回给, 际的调用者, 经过一系列流程处理的.

#####################################

熔断器工作的详细过程如下:

第一步
调用allowRequest()判断是否允许将请求提交到线程池
如果熔断器强制打开, circuitBreaker.forceOpen为true, 不允许放行, 返回.
如果熔断器强制关闭, circuitBreaker.forceClosed为true, 允许放行.
此外不必关注熔断器实际状态, 也就是说熔断器仍然会维护统计数据和开关状态, 只是不生效而已.

第二步
调用isOpen()判断熔断器开关是否打开
如果熔断器开关打开, 进入第三步, 否则继续；
如果一个周期内总的请求数小于circuitBreaker.requestVolumeThreshold的值, 允许请求放行, 否则继续.
如果一个周期内错误率小于circuitBreaker.errorThresholdPercentage的值, 允许请求放行, 否则, 打开熔断器开关, 进入第三步.

第三步
调用allowSingleTest()判断是否允许单个请求通行, 检查依赖服务是否恢复
如果熔断器打开, 且距离熔断器打开的时间或上一次试探请求放行的时间超过circuitBreaker.sleepWindowInMilliseconds的值时,
熔断器器进入半开状态, 允许放行一个试探请求, 否则, 不允许放行.
此外, 为了提供决策依据, 每个熔断器默认维护了10个bucket, 每秒一个bucket, 当新的bucket被创建时,
最旧的bucket会被抛弃. 其中每个blucket维护了请求成功、失败、超时、拒绝的计数器, Hystrix负责收集并统计这些计数器.