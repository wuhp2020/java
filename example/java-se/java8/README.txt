synchronized

原理:
实质是使用moniter对象头Mark Word的标志位实现

特点:
重量锁高并发场景下效率低下
保证线程对变量访问的可见性、排他性、原子性
可见性：修改变量保证其他线程可见
排他性：同一时刻只能一个线程访问
原子性：对变量的操作保证原子执行，例如：i++就是经典的读改写操作

#####################################

cas

原理:
利用操作系统指令原子执行操作, 一般结合自旋实现

特点:
高级并发包下配合AQS一起可提升并发效率
通过不断自旋实现原子更新操作, 高并发场景下虽去掉了锁的概念, 但过多无效空旋也会占用CPU时间

#####################################

NIO 重要知识点详细介绍:
1、通道和缓冲区
Java NIO 系统的核心在于: 通道（Channel）和缓冲区（Buffer）.
通道表示打开到 IO 设备（例如: 文件、套接字）的连接.若需要使用 NIO 系统,
需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区.
然后操作缓冲区, 对数据进行处理. 简而言之, Channel 负责传输, Buffer 负责存储

2、面向流和面向缓冲区解释
IO传输数据面对的直接就是管道里面一个个字节数据的流动, 所以我们说原来的 IO 是面向流的
传统的 IO 流是单向的

NIO通道本身不能传输数据, 要想传输数据必须要有缓冲区

3、缓冲区的数据存取
a. 缓冲区的类型
缓冲区（Buffer）: 一个用于特定基本数据类型的容器.
由 java.nio 包定义的, 所有缓冲区都是 Buffer 抽象类的子类
ByteBuffer
CharBuffer
ShortBuffer
IntBuffer
LongBuffer
FloatBuffer
DoubleBuffer

上述缓冲区管理方式几乎一致, 都是通过 allocate() 来获取缓冲区

b. 缓冲区存取数据的两个核心方法
put(): 存入数据到缓冲区中
get(): 获取缓冲区中的数据

c. 缓冲区中的四个核心属性
capacity: 容量, 表示缓冲区中最大存储数据的容量, 一旦声明不能更改
limit: 界限, 表示缓冲区中可以操作数据的大小.（limit 后的数据不能进行读写）
position: 位置, 表示缓冲区中正在操作数据的位置
mark: 标记, 表示记录当前 position 的位置, 可以通过 reset() 恢复到 mark 的位置

0 <= mark <= position <= limit <= capacity

4、直接缓冲区与非直接缓冲区
非直接缓冲区: 通过 allocate() 方法分配缓冲区, 将缓冲区建立在 JVM 的内存之中
直接缓冲区: 通过 allocateDirect() 方法分配缓冲区, 将缓冲区建立在物理内存之中

5、通道
a. 主要实现类:
java.nio.channels.Channel 包下:
FileChannel
SocketChannel
ServerSocketChannel
DatagramChannel

b. 获取通道
本地 IO:
FileInputStream/FileOutputStream
RandomAccessFile

网络 IO:
Socket
ServerSocket
DatagramSocket

以上几个类都可以通过调用 getChannel() 方法获取通道

6、分散读取与聚集写入
分散读取（Scattering Reads）是指从 Channel 中读取的数据 "分散" 到多个 Buffer 中
聚集写入（Gathering Writes）是指将多个 Buffer 中的数据 "聚集" 到 Channel

#####################################

锁升级:
所谓锁的升级、降级, 就是 JVM 优化 synchronized 运行的机制,
当 JVM 检测到不同的竞争状况时, 会自动切换到适合的锁实现, 这种切换就是锁的升级、降级:
jdk 1.6以前synchronized 关键字只表示重量级锁, 1.6之后区分为偏向锁、轻量级锁、重量级锁

当没有竞争出现时, 默认会使用偏向锁, JVM 会利用 CAS 操作（compare and swap）,
在对象头上的 Mark Word 部分设置线程 ID, 以表示这个对象偏向于当前线程, 所以并不涉及真正的互斥锁,
这样做的假设是基于在很多应用场景中, 大部分对象生命周期中最多会被一个线程锁定, 使用偏向锁可以降低无竞争开销.
如果有另外的线程试图锁定某个已经被偏向过的对象, JVM 就需要撤销（revoke）偏向锁,
并切换到轻量级锁实现, 轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁, 如果重试成功, 就使用轻量级锁,
否则, 进一步升级为重量级锁

javap -c DemoExample1.class
查看指令

每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针:
当执行 monitorenter 时, 如果目标锁对象的计数器为 0, 那么说明它没有被其他线程所持有.
在这个情况下, Java 虚拟机会将该锁对象的持有线程设置为当前线程, 并且将其计数器加 1.

在目标锁对象的计数器不为 0 的情况下, 如果锁对象的持有线程是当前线程, 那么 Java 虚拟机可以将其计数器加 1,
否则需要等待, 直至持有线程释放该锁. 当执行 monitorexit 时, Java 虚拟机则需将锁对象的计数器减 1,
当计数器减为 0 时, 那便代表该锁已经被释放掉了.

之所以采用这种计数器的方式, 是为了允许同一个线程重复获取同一把锁.
举个例子, 如果一个 Java 类中拥有多个 synchronized 方法, 那么这些方法之间的相互调用,
不管是直接的还是间接的, 都会涉及对同一把锁的重复加锁操作. 因此, 我们需要设计这么一个可重入的特性,
来避免编程里的隐式约束.

总结:
偏向锁，轻量级锁都是乐观锁, 重量级锁是悲观锁.
一个对象刚开始实例化的时候, 没有任何线程来访问它的时候. 它是可偏向的, 意味着,
它现在认为只可能有一个线程来访问它, 所以当第一个线程来访问它的时候, 它会偏向这个线程,
此时, 对象持有偏向锁. 偏向第一个线程, 这个线程在修改对象头成为偏向锁的时候使用CAS操作,
并将对象头中的ThreadID改成自己的ID, 之后再次访问这个对象时, 只需要对比ID, 不需要再使用CAS在进行操作.

一旦有第二个线程访问这个对象, 因为偏向锁不会主动释放, 所以第二个线程可以看到对象时偏向状态,
这时表明在这个对象上已经存在竞争了, 检查原来持有该对象锁的线程是否依然存活,
如果挂了, 则可以将对象变为无锁状态, 然后重新偏向新的线程, 如果原来的线程依然存活,
则马上执行那个线程的操作栈, 检查该对象的使用情况, 如果仍然需要持有偏向锁,
则偏向锁升级为轻量级锁,（偏向锁就是这个时候升级为轻量级锁的）. 如果不存在使用了,
则可以将对象回复成无锁状态, 然后重新偏向.

轻量级锁认为竞争存在, 但是竞争的程度很轻, 一般两个线程对于同一个锁的操作都会错开,
或者说稍微等待一下（自旋）, 另一个线程就会释放锁.
但是当自旋超过一定的次数, 或者一个线程在持有锁, 一个在自旋, 又有第三个来访时,
轻量级锁膨胀为重量级锁, 重量级锁使除了拥有锁的线程以外的线程都阻塞, 防止CPU空转.

#####################################

CAS原理:
unsafe.compareAndSwapInt(this, valueOffset, expect, update)

所谓的 CAS, 其实是个简称, 全称是 Compare And Swap, 对比之后交换数据.
上面的方法, 有几个重要的参数:
（1）this, Unsafe 对象本身, 需要通过这个类来获取 value 的内存偏移地址
（2）valueOffset, value 变量的内存偏移地址
（3）expect, 期望更新的值
（4）update, 要更新的最新值

如果原子变量中的 value 值等于 expect, 则使用 update 值更新该值并返回 true, 否则返回 false

#####################################

类的返射:
通过类说明可以得到类的父类、实现的接口、内部类、构造函数、方法、属性并可以根据构造器实例化一个对象,
唤起一个方法, 取属性值, 改属性值. 如何得到一个类说明:
Class cls=类.class;
Class cls=对象.getClass();
Class.forName("类路径");

如何得到一个方法并唤起它:
Class cls=类.class;
Constructor cons=cls.getConstructor(new Class[]{String.class});
Object obj=cons.newInstance(new Object[]{"aaa"});
Method method=cls.getMethod("方法名",new Class[]{String.class,Integer.class});
method.invoke(obj,new Object[]{"aa",new Integer(1)});

#####################################

为什么到8转为红黑树, 到6转为链表?
1. TreeNodes(红黑树)占用空间是普通Nodes(链表)的两倍, 为了时间和空间的权衡.
hash桶中存放的链表长度概率, 随着长度的增加而减小.
2. 节点的分布频率会遵循泊松分布, 链表长度达到8个元素的概率为0.00000006, 几乎是不可能事件.
3. 为什么转化为红黑树的阈值8和转化为链表的阈值6不一样? 是为了避免频繁来回转化.

#####################################

fail-fast机制:
有两个线程（线程A，线程B）, 其中线程A负责遍历list、线程B修改list.
线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N）,
线程启动, 同时线程B增加一个元素, 这是modCount的值发生改变（modCount + 1 = N + 1）.
线程A继续遍历执行next方法时, 通告checkForComodification方法发现expectedModCount = N,
而modCount = N + 1, 两者不等, 这时就抛出ConcurrentModificationException 异常, 从而产生fail-fast机制.

fail-fast解决办法:
方案一: 在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList,
这样就可以解决. 但是不推荐, 因为增删造成的同步锁可能会阻塞遍历操作.
方案二: 使用CopyOnWriteArrayList来替换ArrayList. 推荐使用该方案.

#####################################

hash散列函数:
HashMap采用简单的除法散列, 其散列公式可表示为:
一般来讲, 采用除法散列, m的值应该尽量避免某些特殊值, 例如m不应该为2的幂.
如果m=2^p, 那么h(k)的结果就是k的p个最低位, 这样就会与k的比特位产生关联, 更容易产生冲突,
不能很好的保证散列函数的结果在[0...m-1]之间均匀分布. 所以除非已知各种最低p为排列是等可能的, 否则m选择应该考虑到关键字的所有位.
但是HashMap中提供了hash(int h)函数, 这个函数以key.hashCode为参数, 对其做进一步的处理,
处理过程中较好的解决了以上的因素的影响, 大致保证了每一个hashCode具有有限的冲突次数.