seata-server配置修改:
1.file.conf
store {
  ## store mode: file、db
  mode = "file"
}

2.registry.conf
registry {
  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa
  type = "eureka"
}


#####################################

Seata框架中一个分布式事务包含3中角色:
TM: 事务发起者, 用来告诉TC全局事务的开始、提交、回滚
RM: 事务资源, 每一个RM都会作为一个分支事务注册在TC
TC: 事务协调者, 即独立运行的seata-server, 用于接收事务注册, 提交和回滚

#####################################


一个分布式事务在Seata中的执行流程:
1. TM 向 TC 申请开启一个全局事务, 全局事务创建成功并生成一个全局唯一的 XID
2. XID 在微服务调用链路的上下文中传播
3. RM 向 TC 注册分支事务, 接着执行这个分支事务并提交
（重点: RM在第一阶段就已经执行了本地事务的提交/回滚）, 最后将执行结果汇报给TC

4. TM 根据 TC 中所有的分支事务的执行情况, 发起全局提交或回滚决议
5. TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求


Seata能够在第一阶段直接提交事务, 是因为Seata框架为每一个RM维护了一张UNDO_LOG表
（这张表需要客户端自行创建）, 其中保存了每一次本地事务的回滚数据.
因此, 二阶段的回滚并不依赖于本地数据库事务的回滚, 而是RM直接读取这张UNDO_LOG表,
并将数据库中的数据更新为UNDO_LOG中存储的历史数据

#####################################

两阶段提交（2PC）
两阶段提交又称2PC（two-phase commit protocol）, 2pc是一个非常经典的强一致、中心化的原子提交协议.
这里所说的中心化是指协议中有两类节点: 一个是中心化协调者节点(coordinator)和N个参与者节点(partcipant)

三阶段提交（3PC）
三阶段提交又称3PC, 其在两阶段提交的基础上增加了CanCommit阶段, 并引入了超时机制.
一旦事务参与者迟迟没有收到协调者的Commit请求, 就会自动进行本地commit, 这样相对有效地解决了协调者单点故障的问题

补偿事务（TCC）
TCC（Try-Confirm-Cancel）又称补偿事务.
其核心思想是: "针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）"
分为三个操作:
Try阶段: 主要是对业务系统做检测及资源预留
Confirm阶段: 确认执行业务操作
Cancel阶段: 取消执行业务操作

#####################################



