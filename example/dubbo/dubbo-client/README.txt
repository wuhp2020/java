RPC使用的关键技术:

1、动态代理
生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术,
可以使用JDK提供的原生的动态代理机制, 也可以使用开源的: CGLib代理, Javassist字节码生成技术.

2、序列化和反序列化
在网络中, 所有的数据都将会被转化为字节进行传送, 所以为了能够使参数对象在网络中进行传输, 需要对这些参数进行序列化和反序列化操作.
序列化: 把对象转换为字节序列的过程称为对象的序列化, 也就是编码的过程.
反序列化: 把字节序列恢复为对象的过程称为对象的反序列化, 也就是解码的过程.
目前比较高效的开源序列化框架: 如Kryo、FastJson和Protobuf等.

3、NIO通信
出于并发性能的考虑, 传统的阻塞式 IO 显然不太合适, 因此我们需要异步的 IO，即 NIO.
Java 提供了 NIO 的解决方案, Java 7 也提供了更优秀的 NIO.2 支持.
可以选择Netty或者MINA来解决NIO数据传输的问题.

4、服务注册中心
可选: Redis、Zookeeper、Consul 、Etcd.
一般使用ZooKeeper提供服务注册与发现功能, 解决单点故障以及分布式部署的问题(注册中心).

#####################################

RPC原理:
1. 服务消费方（client）调用以本地调用方式调用服务
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体
3. client stub找到服务地址, 并将消息发送到服务端
4. server stub收到消息后进行解码
5. server stub根据解码结果调用本地的服务
6. 本地服务执行并将结果返回给server stub
7. server stub将返回结果打包成消息并发送至消费方
8. client stub接收到消息, 并进行解码
9. 服务消费方得到最终结果


RPC的目标就是要2~8这些步骤都封装起来, 让用户对这些细节透明:
1. 怎么做到透明化远程服务调用?
jdk 动态代理
字节码生成


2. 怎么对消息进行编码和解码?
2.1 确定消息数据结构
客户端的请求消息结构一般需要包括以下内容:
1）接口名称
在我们的例子里接口名是“HelloWorldService”, 如果不传, 服务端就不知道调用哪个接口了
2）方法名
一个接口内可能有很多方法, 如果不传方法名服务端也就不知道调用哪个方法
3）参数类型&参数值
参数类型有很多, 比如有bool、int、long、double、string、map、list, 甚至如struct（class）, 以及相应的参数值
4）超时时间
5）requestID, 标识唯一请求id, 在下面一节会详细描述requestID的用处

服务端返回的消息结构一般包括以下内容:
1）返回值
2）状态code
3）requestID

2.2 序列化
通用性: 比如是否能支持Map等复杂的数据结构.
性能:   包括时间复杂度和空间复杂度, 由于RPC框架将会被公司几乎所有服务使用,
如果序列化上能节约一点时间, 对整个公司的收益都将非常可观, 同理如果序列化上能节约一点内存, 网络带宽也能省下不少.
可扩展性:对互联网公司而言, 业务变化飞快, 如果序列化协议具有良好的可扩展性,
支持自动增加新的业务字段, 而不影响老的服务, 这将大大提供系统的灵活度


3. 通信
使用java nio方式自研, 这种方式较为复杂, 而且很有可能出现隐藏bug, 但也见过一些互联网公司使用这种方式.
基于mina，mina在早几年比较火热, 不过这些年版本更新缓慢.
基于netty, 现在很多RPC框架都直接基于netty这一IO通信框架, 省力又省心, 比如阿里巴巴的HSF、dubbo, Twitter的finagle等.

4. 消息里为什么要有requestID?
如果使用netty的话, 一般会用channel.writeAndFlush()方法来发送消息二进制串,
这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的, 即对于当前线程来说,
将请求发送出来后, 线程就可以往后执行了, 至于服务端的结果, 是服务端处理完成后, 再以消息的形式发送给客户端的.
于是这里出现以下两个问题:

怎么让当前线程“暂停”, 等结果回来后, 再向后执行?
如果有多个线程同时进行远程方法调用, 这时建立在client server之间的socket连接上会有很多双方发送的消息传递,
前后顺序也可能是随机的, server处理完结果后, 将结果消息发送给client, client收到很多消息,
怎么知道哪个消息结果是原先哪个线程调用的?
解决:
client线程每次通过socket调用一次远程接口前, 生成一个唯一的ID,
即requestID（requestID必需保证在一个Socket连接里面是唯一的）, 一般常常使用AtomicLong从0开始累计数字生成唯一ID.
将处理结果的回调对象callback, 存放到全局ConcurrentHashMap里面put(requestID, callback),
当线程调用channel.writeAndFlush()发送消息后, 紧接着执行callback的get()方法试图获取远程返回的结果.
在get()内部, 则使用synchronized获取回调对象callback的锁, 再先检测是否已经获取到结果,
如果没有, 然后调用callback的wait()方法, 释放callback上的锁, 让当前线程处于等待状态.
服务端接收到请求并处理后, 将response结果（此结果中包含了前面的requestID）发送给客户端,
客户端socket连接上专门监听消息的线程收到消息, 分析结果, 取到requestID,
再从前面的ConcurrentHashMap里面get(requestID), 从而找到callback对象,
再用synchronized获取callback上的锁, 将方法调用结果设置到callback对象里,
再调用callback.notifyAll()唤醒前面处于等待状态的线程.



