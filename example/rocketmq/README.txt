安装:
解压后, 修改堆栈大小, 执行:
nohup sh ./bin/mqnamesrv > ./logs/nameserver.log 2>&1 &
nohup sh ./bin/mqbroker -n 127.0.0.1:9876 -c ./conf/broker.conf autoCreateTopicEnable=true > ./logs/broker.log 2>&1 &

#####################################

             Kafka	         RocketMQ	               RabbitMQ	                 ActiveMQ
单机吞吐量	 10万级	         10万级	                     万级	                  万级
开发语言	     Scala	          Java	                   Erlang	                   Java
高可用	    分布式架构	    分布式架构	               主从架构	                 主从架构
性能	     ms级	          ms级	                    us级	                  ms级
功能	  只支持主要的MQ功能  顺序消息、事务消息等功能完善	并发强、性能好、延时低	     成熟的社区产品、文档丰富

#####################################

异步发送, 那消息可靠性怎么保证:
消息丢失可能发生在生产者发送消息、MQ本身丢失消息、消费者丢失消息3个方面.

#####################################

消息在master和slave之间的同步是根据raft协议来进行的:
在broker收到消息后, 会被标记为uncommitted状态
然后会把消息发送给所有的slave
slave在收到消息之后返回ack响应给master
master在收到超过半数的ack之后, 把消息标记为committed
发送committed消息给所有slave, slave也修改状态为committed

#####################################

RocketMQ为什么速度快:
是因为使用了顺序存储、Page Cache和异步刷盘.

#####################################

事务、半事务消息怎么实现的:
事务消息就是MQ提供的类似XA的分布式事务能力, 通过事务消息可以达到分布式事务的最终一致性.
半事务消息就是MQ收到了生产者的消息, 但是没有收到二次确认, 不能投递的消息.

实现原理如下:
生产者先发送一条半事务消息到MQ
MQ收到消息后返回ack确认
生产者开始执行本地事务
如果事务执行成功发送commit到MQ, 失败发送rollback
如果MQ长时间未收到生产者的二次确认commit或者rollback, MQ对生产者发起消息回查
生产者查询事务执行最终状态
根据查询事务状态再次提交二次确认
最终, 如果MQ收到二次确认commit, 就可以把消息投递给消费者, 反之如果是rollback, 消息会保存下来并且在3天后被删除.

#####################################

解决消息重复投递的问题
增加转账消息应用状态表（message_apply), 通俗来说就是个账本, 用于记录消息的消费情况,
每次来一个消息, 在真正执行之前, 先去消息应用状态表中查询一遍, 如果找到说明是重复消息, 丢弃即可,
如果没找到才执行, 同时插入到消息应用状态表（同一事务）.

#####################################

全局顺序消息
RocketMQ 在默认情况下不保证顺序, 要保证全局顺序, 需要把 Topic 的读写队列数设置为 1,
然后生产者和消费者的并发设置也是 1. 所以这样的话 高并发, 高吞吐量的功能完全用不上.
mqadmin update Topic -t AllOrder -c DefaultCluster -r 1 -w 1 -n 127.0.0.1:9876

#####################################

延时消息
Producer 将消息发送到消息队列 RocketMQ 服务端, 但并不期望这条消息立马投递,
而是延迟一定时间后才投递到 Consumer 进行消费, 该消息即延时消息.

适用场景
消息生产和消费有时间窗口要求:
比如在电商交易中超时未支付关闭订单的场景, 在订单创建时会发送一条延时消息. 这条消息将会在 30 分钟以 后投递给消费者,
消费者收到此消息后需要判断对应的订单是否已完成支付. 如支付未完成, 则关闭订单. 如已完成支付则忽略.

死信队列
一个死信队列对应一个 Group ID, 而不是对应单个消费者实例.
如果一个 Group ID 未产生死信消息, 消息队列 MQ 不会为其创建相应的死信队列.
一个死信队列包含了对应 Group ID 产生的所有死信消息, 不论该消息属于哪个 Topic.
消息队列 MQ 控制台提供对死信消息的查询的功能.
命令查看死信队列:
sh mqadmin updateTopic -b 127.0.0.1:10911 -n 127.0.0.1:9876 -t %DLQ%group1 -p 6

