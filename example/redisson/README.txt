加锁流程
1. 选择一个redis master
  a. 首先会做一个判断,判断我们的key是否包含{}, 如果包含{}, 那么就用只用这块做crc16的计算, 否则就用整个key做crc16计算
  b. crc16计算后是一个int类型的值, 用这个值与16384取模, 判断这个key应该放到哪个槽里
  c. 现在已经知道这个key要放到哪个槽里了, 然后redisson里面保存了每一个槽对应的redis节点信息, 放在了一个AtomicReferenceArray中, 从里面取出对应槽对应的节点信息
2. 准备执行lua脚本, 设置分布式锁
  a. 这个锁是一个hash结构, 就是类似于我们Java中的map
  b. key是我们自己设置的那个锁的名字
  c. hash中的field就是 当前redisson客户端的连接管理器的id(就是个UUID) + 当前线程id组成
  d. value中就是这个锁重入的次数
3. 此时有3种情况
  a. 这个key不存在
    ⅰ. 直接把自己设置进入, 并且设置key的超时时间, 默认是30s
  b. 这个key存在, 但是自己的连接id+线程id 在这个hash的属性中, 也就是持有锁的是自己
    ⅰ. 把属性的值+1, 也就是重入一次, 然后把超时时间重新设置一下
  c. 上面两种都不是, 也就是持有锁的人不是自己
    ⅰ. 返回这个key超时的毫秒数
4. 如果刚刚执行的lua脚本返回的是null, 也就是说现在持有锁的是自己, 那么就启动一个看门狗(后台线程),
默认每个10秒钟去续命一次, 当然了, 可以续命的前提是这把锁还在, 如果因为gc或者网络等问题, 导致锁超时,
那么看门狗就无法续命了(需要注意的是, 看门狗只会在我们没有指定超时时间的时候帮我们续命, 如果自己指定了超时时间, 那么看门狗是没法帮我们续命的)
5. 如果返回的不是null, 也就是自己没有获取到锁, 那么就搞了一个发布订阅模式, 作为监听, 如果其他线程释放了锁,
自己再去竞争锁, 当然了, 它也不会一直傻傻的在订阅, 如果持有锁的客户端挂了, 那没人给自己发布一个消息,
所以自己也搞了一个超时时间, 就是用刚刚lua脚本返回的时间作为超时时间, 超时后再来竞争一下锁试试.


解锁流程
1. 会判断当前这个锁在不在, 如果不在, 那么直接发送一个订阅消息 0, 说这个锁已经被解开了
2. 如果这把锁存在, 但是不是自己持有, 那么就什么也不做
3. 如果上面两种情况都不符合, 那么就会把这个key中自己对应的属性的值-1
4. 如果-1完成后, 大于0, 那么说明这个锁还没减完
5. 如果-1后不大于0, 那么就说明这把锁已经被释放了, 那么就删除这个锁, 然后pushlish一下, 通知其他人, 这把锁已经被释放了

#####################################

