IO多路复用:
在非阻塞模式下, 用select()方法检测发生变化的通道,
每个通道都关联一个Socket, 用一个线程实现多个客户端的请求, 从而实现多路复用

#####################################

IO通信
1. BIO通信
BIO即同步阻塞模式一请求一应答的通信模型, 该模型最大的问题就是缺乏弹性伸缩能力,
当客户端并发访问量增加后, 服务端的线程个数和客户端并发访问数呈1：1的正比关系,
由于线程是JAVA虚拟机非常宝贵的系统资源, 当线程数膨胀之后, 系统的性能将急剧下降,
随着并发访问量的继续增大, 系统会发生线程堆栈溢出、创建新线程失败等问题, 并最终导致进程宕机或者僵死, 不能对外提供服务.

2. 伪异步IO通信
伪异步IO通信特性:
采用线程池和任务队列实现
线程池负责连接
M请求N应答
线程池阻塞

3. NIO通信
NIO是非阻塞IO（Non-block IO）, 也有人称之为New IO, 因为它相对于之前的IO类库是新增的, 所以被称为New IO, 这是它的官方叫法.
它是在 JDK 1.4 中引入的, NIO 弥补了原来同步阻塞I/O 的不足, 它在标准 Java 代码中提供了高速的、面向块的 I/O.
通过定义包含数据的类, 以及通过以块的形式处理这些数据, NIO 不用使用本机代码就可以利用底层优化, 这是原来的 I/O 包所无法做到的.

NIO之缓冲区Buffer:
Buffer 是一个对象, 它包含一些要写入或者要读出的数据. 在 NIO类库 中加入 Buffer 对象, 体现了新库与原 I/O 的一个重要区别.
在面向流的 I/O 中, 我们将数据直接写入或者将数据直接读到 Stream 对象中.
在 NIO 库中, 所有数据都是用缓冲区进行处理的, 在读取数据时, 它是直接读到缓冲区中; 在写入数据时, 它也是写入到缓冲区中.
任何时候访问 NIO 中的数据, 我们都是通过缓冲区进行读写操作.
缓冲区实质上是一个数组, 通常它是一个字节数组（ByteBuffer）, 也可以使用其它种类的数组.
但是一个缓冲区不仅仅是一个数组, 缓冲区提供了对数据的结构化访问, 及维护读写位置（limit）等信息.

NIO之通道Channel:
Channel是一个通道, 可以通过它读取和写入数据, 它就像自来水管一样, 网络数据通过Channel读取和写入.
通道与流的不同之处在于通道是双向的, 而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类),
而通道可以用于读、写或者同时用于读写.

NIO之多路复用器Selector:
它是JAVA NIO编程的基础, 熟练的掌握Selector对于掌握NIO编程至关重要.
多路复用器提供选择已经就绪的任务的能力, 简单来讲, Selector会不断的轮询注册在其上的Channel,
如果某个Channel上面有新的TCP连接接入、读和写事件, 这个Channel就处于就绪状态, 会被Selector轮询出来,
然后通过SelectionKey可以获取就绪Channel的集合进行后续的IO操作.
一个多路复用器Selector可以同时轮询多个Channel, 由于JDK使用了epoll()代替传统的select实现,
所以它并没有最大连接句柄1024/2048的限制, 这也就意味着只需要一个线程负责Selector的轮询,
就可以接入成千上万的客户端, 这的确是一个巨大的改进.

4. AIO通信
AIO异步通道提供了两种方式获取操作结果:
通过java.util.concurrent.Future类来表示异步操作的结果
在执行异步操作的时候传入一个java.nio.channels.CompletionHandler接口的实现类作为操作完成的回调.
AIO的异步套接字通道是真正的异步非阻塞IO, 对应于UNIX网络编程中的事件驱动IO(AIO),
它不需要通过多路复用器(Selector)对注册的通道进行轮询操作即可实现异步读写, 从而简化了NIO的编程模型.
AIO通信的特性:
连接注册读写事件和回调函数
读写方法异步
主动通知程序



